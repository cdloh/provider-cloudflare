/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessInitParameters struct {

	// Audience tags of the access rule.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Whether the access rule is required.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Name of the team to which the access rule applies.
	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type AccessObservation struct {

	// Audience tags of the access rule.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Whether the access rule is required.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Name of the team to which the access rule applies.
	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type AccessParameters struct {

	// Audience tags of the access rule.
	// +kubebuilder:validation:Optional
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Whether the access rule is required.
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Name of the team to which the access rule applies.
	// +kubebuilder:validation:Optional
	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type ConfigConfigInitParameters struct {

	// Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
	IngressRule []IngressRuleInitParameters `json:"ingressRule,omitempty" tf:"ingress_rule,omitempty"`

	OriginRequest []ConfigOriginRequestInitParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
	WarpRouting []WarpRoutingInitParameters `json:"warpRouting,omitempty" tf:"warp_routing,omitempty"`
}

type ConfigConfigObservation struct {

	// Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
	IngressRule []IngressRuleObservation `json:"ingressRule,omitempty" tf:"ingress_rule,omitempty"`

	OriginRequest []ConfigOriginRequestObservation `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
	WarpRouting []WarpRoutingObservation `json:"warpRouting,omitempty" tf:"warp_routing,omitempty"`
}

type ConfigConfigParameters struct {

	// Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
	// +kubebuilder:validation:Optional
	IngressRule []IngressRuleParameters `json:"ingressRule,omitempty" tf:"ingress_rule,omitempty"`

	// +kubebuilder:validation:Optional
	OriginRequest []ConfigOriginRequestParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
	// +kubebuilder:validation:Optional
	WarpRouting []WarpRoutingParameters `json:"warpRouting,omitempty" tf:"warp_routing,omitempty"`
}

type ConfigInitParameters struct {

	// Configuration block for Tunnel Configuration.
	Config []ConfigConfigInitParameters `json:"config,omitempty" tf:"config,omitempty"`
}

type ConfigObservation struct {

	// The account identifier to target for the resource.
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Configuration block for Tunnel Configuration.
	Config []ConfigConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Identifier of the Tunnel to target for this configuration.
	TunnelID *string `json:"tunnelId,omitempty" tf:"tunnel_id,omitempty"`
}

type ConfigOriginRequestInitParameters struct {

	// Access rules for the ingress service.
	Access []OriginRequestAccessInitParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Runs as jump host.
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Enables HTTP/2 support for the origin connection. Defaults to `false`.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// IP rules for the proxy service.
	IPRules []OriginRequestIPRulesInitParameters `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type ConfigOriginRequestObservation struct {

	// Access rules for the ingress service.
	Access []OriginRequestAccessObservation `json:"access,omitempty" tf:"access,omitempty"`

	// Runs as jump host.
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Enables HTTP/2 support for the origin connection. Defaults to `false`.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// IP rules for the proxy service.
	IPRules []OriginRequestIPRulesObservation `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type ConfigOriginRequestParameters struct {

	// Access rules for the ingress service.
	// +kubebuilder:validation:Optional
	Access []OriginRequestAccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Runs as jump host.
	// +kubebuilder:validation:Optional
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	// +kubebuilder:validation:Optional
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	// +kubebuilder:validation:Optional
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	// +kubebuilder:validation:Optional
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	// +kubebuilder:validation:Optional
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Enables HTTP/2 support for the origin connection. Defaults to `false`.
	// +kubebuilder:validation:Optional
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// IP rules for the proxy service.
	// +kubebuilder:validation:Optional
	IPRules []OriginRequestIPRulesParameters `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	// +kubebuilder:validation:Optional
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	// +kubebuilder:validation:Optional
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	// +kubebuilder:validation:Optional
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	// +kubebuilder:validation:Optional
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	// +kubebuilder:validation:Optional
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	// +kubebuilder:validation:Optional
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	// +kubebuilder:validation:Optional
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
	// +kubebuilder:validation:Optional
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	// +kubebuilder:validation:Optional
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	// +kubebuilder:validation:Optional
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type ConfigParameters struct {

	// The account identifier to target for the resource.
	// +crossplane:generate:reference:type=github.com/clementblaise/provider-cloudflare/apis/account/v1alpha1.Account
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Reference to a Account in account to populate accountId.
	// +kubebuilder:validation:Optional
	AccountIDRef *v1.Reference `json:"accountIdRef,omitempty" tf:"-"`

	// Selector for a Account in account to populate accountId.
	// +kubebuilder:validation:Optional
	AccountIDSelector *v1.Selector `json:"accountIdSelector,omitempty" tf:"-"`

	// Configuration block for Tunnel Configuration.
	// +kubebuilder:validation:Optional
	Config []ConfigConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// Identifier of the Tunnel to target for this configuration.
	// +crossplane:generate:reference:type=Tunnel
	// +kubebuilder:validation:Optional
	TunnelID *string `json:"tunnelId,omitempty" tf:"tunnel_id,omitempty"`

	// Reference to a Tunnel to populate tunnelId.
	// +kubebuilder:validation:Optional
	TunnelIDRef *v1.Reference `json:"tunnelIdRef,omitempty" tf:"-"`

	// Selector for a Tunnel to populate tunnelId.
	// +kubebuilder:validation:Optional
	TunnelIDSelector *v1.Selector `json:"tunnelIdSelector,omitempty" tf:"-"`
}

type IPRulesInitParameters struct {

	// Whether to allow the IP prefix.
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type IPRulesObservation struct {

	// Whether to allow the IP prefix.
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type IPRulesParameters struct {

	// Whether to allow the IP prefix.
	// +kubebuilder:validation:Optional
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type IngressRuleInitParameters struct {

	// Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	OriginRequest []OriginRequestInitParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// Path of the incoming request. If the path matches, the request will be sent to the local service.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Name of the service to which the request will be sent.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type IngressRuleObservation struct {

	// Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	OriginRequest []OriginRequestObservation `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// Path of the incoming request. If the path matches, the request will be sent to the local service.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Name of the service to which the request will be sent.
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type IngressRuleParameters struct {

	// Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	OriginRequest []OriginRequestParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// Path of the incoming request. If the path matches, the request will be sent to the local service.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Name of the service to which the request will be sent.
	// +kubebuilder:validation:Optional
	Service *string `json:"service,omitempty" tf:"service,omitempty"`
}

type OriginRequestAccessInitParameters struct {

	// Audience tags of the access rule.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Whether the access rule is required.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Name of the team to which the access rule applies.
	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type OriginRequestAccessObservation struct {

	// Audience tags of the access rule.
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Whether the access rule is required.
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Name of the team to which the access rule applies.
	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type OriginRequestAccessParameters struct {

	// Audience tags of the access rule.
	// +kubebuilder:validation:Optional
	AudTag []*string `json:"audTag,omitempty" tf:"aud_tag,omitempty"`

	// Whether the access rule is required.
	// +kubebuilder:validation:Optional
	Required *bool `json:"required,omitempty" tf:"required,omitempty"`

	// Name of the team to which the access rule applies.
	// +kubebuilder:validation:Optional
	TeamName *string `json:"teamName,omitempty" tf:"team_name,omitempty"`
}

type OriginRequestIPRulesInitParameters struct {

	// Whether to allow the IP prefix.
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type OriginRequestIPRulesObservation struct {

	// Whether to allow the IP prefix.
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type OriginRequestIPRulesParameters struct {

	// Whether to allow the IP prefix.
	// +kubebuilder:validation:Optional
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type OriginRequestInitParameters struct {

	// Access rules for the ingress service.
	Access []AccessInitParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Runs as jump host.
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Enables HTTP/2 support for the origin connection. Defaults to `false`.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// IP rules for the proxy service.
	IPRules []IPRulesInitParameters `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type OriginRequestObservation struct {

	// Access rules for the ingress service.
	Access []AccessObservation `json:"access,omitempty" tf:"access,omitempty"`

	// Runs as jump host.
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Enables HTTP/2 support for the origin connection. Defaults to `false`.
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// IP rules for the proxy service.
	IPRules []IPRulesObservation `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type OriginRequestParameters struct {

	// Access rules for the ingress service.
	// +kubebuilder:validation:Optional
	Access []AccessParameters `json:"access,omitempty" tf:"access,omitempty"`

	// Runs as jump host.
	// +kubebuilder:validation:Optional
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	// +kubebuilder:validation:Optional
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	// +kubebuilder:validation:Optional
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	// +kubebuilder:validation:Optional
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	// +kubebuilder:validation:Optional
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// Enables HTTP/2 support for the origin connection. Defaults to `false`.
	// +kubebuilder:validation:Optional
	Http2Origin *bool `json:"http2Origin,omitempty" tf:"http2_origin,omitempty"`

	// IP rules for the proxy service.
	// +kubebuilder:validation:Optional
	IPRules []IPRulesParameters `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	// +kubebuilder:validation:Optional
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	// +kubebuilder:validation:Optional
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	// +kubebuilder:validation:Optional
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	// +kubebuilder:validation:Optional
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	// +kubebuilder:validation:Optional
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	// +kubebuilder:validation:Optional
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	// +kubebuilder:validation:Optional
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
	// +kubebuilder:validation:Optional
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	// +kubebuilder:validation:Optional
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	// +kubebuilder:validation:Optional
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type WarpRoutingInitParameters struct {

	// Whether WARP routing is enabled.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type WarpRoutingObservation struct {

	// Whether WARP routing is enabled.
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type WarpRoutingParameters struct {

	// Whether WARP routing is enabled.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

// ConfigSpec defines the desired state of Config
type ConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ConfigParameters `json:"forProvider"`
	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ConfigInitParameters `json:"initProvider,omitempty"`
}

// ConfigStatus defines the observed state of Config.
type ConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Config is the Schema for the Configs API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Config struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.config) || has(self.initProvider.config)",message="config is a required parameter"
	Spec   ConfigSpec   `json:"spec"`
	Status ConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigList contains a list of Configs
type ConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Config `json:"items"`
}

// Repository type metadata.
var (
	Config_Kind             = "Config"
	Config_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Config_Kind}.String()
	Config_KindAPIVersion   = Config_Kind + "." + CRDGroupVersion.String()
	Config_GroupVersionKind = CRDGroupVersion.WithKind(Config_Kind)
)

func init() {
	SchemeBuilder.Register(&Config{}, &ConfigList{})
}
