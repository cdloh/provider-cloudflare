/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigObservation struct {
}

type ConfigParameters struct {

	// Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
	// +kubebuilder:validation:Required
	IngressRule []IngressRuleParameters `json:"ingressRule" tf:"ingress_rule,omitempty"`

	// +kubebuilder:validation:Optional
	OriginRequest []OriginRequestParameters `json:"originRequest,omitempty" tf:"origin_request,omitempty"`

	// If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
	// +kubebuilder:validation:Optional
	WarpRouting []WarpRoutingParameters `json:"warpRouting,omitempty" tf:"warp_routing,omitempty"`
}

type IPRulesObservation struct {
}

type IPRulesParameters struct {

	// Whether to allow the IP prefix.
	// +kubebuilder:validation:Optional
	Allow *bool `json:"allow,omitempty" tf:"allow,omitempty"`

	// Ports to use within the IP rule.
	// +kubebuilder:validation:Optional
	Ports []*float64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// IP rule prefix.
	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`
}

type IngressRuleObservation struct {
}

type IngressRuleParameters struct {

	// Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// Path of the incoming request. If the path matches, the request will be sent to the local service.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Name of the service to which the request will be sent.
	// +kubebuilder:validation:Required
	Service *string `json:"service" tf:"service,omitempty"`
}

type OriginRequestObservation struct {
}

type OriginRequestParameters struct {

	// Runs as jump host.
	// +kubebuilder:validation:Optional
	BastionMode *bool `json:"bastionMode,omitempty" tf:"bastion_mode,omitempty"`

	// Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
	// +kubebuilder:validation:Optional
	CAPool *string `json:"caPool,omitempty" tf:"ca_pool,omitempty"`

	// Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
	// +kubebuilder:validation:Optional
	ConnectTimeout *string `json:"connectTimeout,omitempty" tf:"connect_timeout,omitempty"`

	// Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
	// +kubebuilder:validation:Optional
	DisableChunkedEncoding *bool `json:"disableChunkedEncoding,omitempty" tf:"disable_chunked_encoding,omitempty"`

	// Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
	// +kubebuilder:validation:Optional
	HTTPHostHeader *string `json:"httpHostHeader,omitempty" tf:"http_host_header,omitempty"`

	// IP rules for the proxy service.
	// +kubebuilder:validation:Optional
	IPRules []IPRulesParameters `json:"ipRules,omitempty" tf:"ip_rules,omitempty"`

	// Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
	// +kubebuilder:validation:Optional
	KeepAliveConnections *float64 `json:"keepAliveConnections,omitempty" tf:"keep_alive_connections,omitempty"`

	// Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
	// +kubebuilder:validation:Optional
	KeepAliveTimeout *string `json:"keepAliveTimeout,omitempty" tf:"keep_alive_timeout,omitempty"`

	// Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
	// +kubebuilder:validation:Optional
	NoHappyEyeballs *bool `json:"noHappyEyeballs,omitempty" tf:"no_happy_eyeballs,omitempty"`

	// Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
	// +kubebuilder:validation:Optional
	NoTLSVerify *bool `json:"noTlsVerify,omitempty" tf:"no_tls_verify,omitempty"`

	// Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
	// +kubebuilder:validation:Optional
	OriginServerName *string `json:"originServerName,omitempty" tf:"origin_server_name,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
	// +kubebuilder:validation:Optional
	ProxyAddress *string `json:"proxyAddress,omitempty" tf:"proxy_address,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
	// +kubebuilder:validation:Optional
	ProxyPort *float64 `json:"proxyPort,omitempty" tf:"proxy_port,omitempty"`

	// cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: “, `socks`. Defaults to `""`.
	// +kubebuilder:validation:Optional
	ProxyType *string `json:"proxyType,omitempty" tf:"proxy_type,omitempty"`

	// The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
	// +kubebuilder:validation:Optional
	TCPKeepAlive *string `json:"tcpKeepAlive,omitempty" tf:"tcp_keep_alive,omitempty"`

	// Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
	// +kubebuilder:validation:Optional
	TLSTimeout *string `json:"tlsTimeout,omitempty" tf:"tls_timeout,omitempty"`
}

type TunnelConfigObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TunnelConfigParameters struct {

	// The account identifier to target for the resource.
	// +kubebuilder:validation:Required
	AccountID *string `json:"accountId" tf:"account_id,omitempty"`

	// Configuration block for Tunnel Configuration.
	// +kubebuilder:validation:Required
	Config []ConfigParameters `json:"config" tf:"config,omitempty"`

	// Identifier of the Tunnel to target for this configuration.
	// +crossplane:generate:reference:type=Tunnel
	// +kubebuilder:validation:Optional
	TunnelID *string `json:"tunnelId,omitempty" tf:"tunnel_id,omitempty"`

	// Reference to a Tunnel to populate tunnelId.
	// +kubebuilder:validation:Optional
	TunnelIDRef *v1.Reference `json:"tunnelIdRef,omitempty" tf:"-"`

	// Selector for a Tunnel to populate tunnelId.
	// +kubebuilder:validation:Optional
	TunnelIDSelector *v1.Selector `json:"tunnelIdSelector,omitempty" tf:"-"`
}

type WarpRoutingObservation struct {
}

type WarpRoutingParameters struct {

	// Whether WARP routing is enabled.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

// TunnelConfigSpec defines the desired state of TunnelConfig
type TunnelConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TunnelConfigParameters `json:"forProvider"`
}

// TunnelConfigStatus defines the observed state of TunnelConfig.
type TunnelConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TunnelConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// TunnelConfig is the Schema for the TunnelConfigs API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type TunnelConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TunnelConfigSpec   `json:"spec"`
	Status            TunnelConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TunnelConfigList contains a list of TunnelConfigs
type TunnelConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TunnelConfig `json:"items"`
}

// Repository type metadata.
var (
	TunnelConfig_Kind             = "TunnelConfig"
	TunnelConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: TunnelConfig_Kind}.String()
	TunnelConfig_KindAPIVersion   = TunnelConfig_Kind + "." + CRDGroupVersion.String()
	TunnelConfig_GroupVersionKind = CRDGroupVersion.WithKind(TunnelConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&TunnelConfig{}, &TunnelConfigList{})
}
