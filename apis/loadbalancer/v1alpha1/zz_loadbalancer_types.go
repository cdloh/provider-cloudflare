/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdaptiveRoutingObservation struct {
}

type AdaptiveRoutingParameters struct {

	// Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
	// +kubebuilder:validation:Optional
	FailoverAcrossPools *bool `json:"failoverAcrossPools,omitempty" tf:"failover_across_pools,omitempty"`
}

type CountryPoolsObservation struct {
}

type CountryPoolsParameters struct {

	// A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
	// +kubebuilder:validation:Required
	Country *string `json:"country" tf:"country,omitempty"`

	// A list of pool IDs in failover priority to use in the given country.
	// +crossplane:generate:reference:type=Pool
	// +kubebuilder:validation:Optional
	PoolIds []*string `json:"poolIds,omitempty" tf:"pool_ids,omitempty"`

	// References to Pool to populate poolIds.
	// +kubebuilder:validation:Optional
	PoolIdsRefs []v1.Reference `json:"poolIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Pool to populate poolIds.
	// +kubebuilder:validation:Optional
	PoolIdsSelector *v1.Selector `json:"poolIdsSelector,omitempty" tf:"-"`
}

type FixedResponseObservation struct {
}

type FixedResponseParameters struct {

	// The value of the HTTP context-type header for this fixed response.
	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// The value of the HTTP location header for this fixed response.
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The text used as the html body for this fixed response.
	// +kubebuilder:validation:Optional
	MessageBody *string `json:"messageBody,omitempty" tf:"message_body,omitempty"`

	// The HTTP status code used for this fixed response.
	// +kubebuilder:validation:Optional
	StatusCode *float64 `json:"statusCode,omitempty" tf:"status_code,omitempty"`
}

type LoadBalancerObservation struct {

	// The RFC3339 timestamp of when the load balancer was created.
	CreatedOn *string `json:"createdOn,omitempty" tf:"created_on,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The RFC3339 timestamp of when the load balancer was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`
}

type LoadBalancerParameters struct {

	// Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
	// +kubebuilder:validation:Optional
	AdaptiveRouting []AdaptiveRoutingParameters `json:"adaptiveRouting,omitempty" tf:"adaptive_routing,omitempty"`

	// A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
	// +kubebuilder:validation:Optional
	CountryPools []CountryPoolsParameters `json:"countryPools,omitempty" tf:"country_pools,omitempty"`

	// A list of pool IDs ordered by their failover priority. Used whenever [`pop_pools`](#pop_pools)/[`country_pools`](#country_pools)/[`region_pools`](#region_pools) are not defined.
	// +crossplane:generate:reference:type=Pool
	// +kubebuilder:validation:Optional
	DefaultPoolIds []*string `json:"defaultPoolIds,omitempty" tf:"default_pool_ids,omitempty"`

	// References to Pool to populate defaultPoolIds.
	// +kubebuilder:validation:Optional
	DefaultPoolIdsRefs []v1.Reference `json:"defaultPoolIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Pool to populate defaultPoolIds.
	// +kubebuilder:validation:Optional
	DefaultPoolIdsSelector *v1.Selector `json:"defaultPoolIdsSelector,omitempty" tf:"-"`

	// Free text description.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Enable or disable the load balancer. Defaults to `true`.
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The pool ID to use when all other pools are detected as unhealthy.
	// +crossplane:generate:reference:type=Pool
	// +kubebuilder:validation:Optional
	FallbackPoolID *string `json:"fallbackPoolId,omitempty" tf:"fallback_pool_id,omitempty"`

	// Reference to a Pool to populate fallbackPoolId.
	// +kubebuilder:validation:Optional
	FallbackPoolIDRef *v1.Reference `json:"fallbackPoolIdRef,omitempty" tf:"-"`

	// Selector for a Pool to populate fallbackPoolId.
	// +kubebuilder:validation:Optional
	FallbackPoolIDSelector *v1.Selector `json:"fallbackPoolIdSelector,omitempty" tf:"-"`

	// Controls location-based steering for non-proxied requests.
	// +kubebuilder:validation:Optional
	LocationStrategy []LocationStrategyParameters `json:"locationStrategy,omitempty" tf:"location_strategy,omitempty"`

	// The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
	// +kubebuilder:validation:Optional
	PopPools []PopPoolsParameters `json:"popPools,omitempty" tf:"pop_pools,omitempty"`

	// Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.
	// +kubebuilder:validation:Optional
	Proxied *bool `json:"proxied,omitempty" tf:"proxied,omitempty"`

	// Configures pool weights for random steering. When the [`steering_policy="random"`](#steering_policy), a random pool is selected with probability proportional to these pool weights.
	// +kubebuilder:validation:Optional
	RandomSteering []RandomSteeringParameters `json:"randomSteering,omitempty" tf:"random_steering,omitempty"`

	// A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
	// +kubebuilder:validation:Optional
	RegionPools []RegionPoolsParameters `json:"regionPools,omitempty" tf:"region_pools,omitempty"`

	// A list of rules for this load balancer to execute.
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// Specifies the type of session affinity the load balancer should use unless specified as `none` or `""` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `""`, `none`, `cookie`, `ip_cookie`. Defaults to `none`.
	// +kubebuilder:validation:Optional
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// See [`session_affinity_attributes`](#nested-schema-for-session_affinity_attributes).
	// +kubebuilder:validation:Optional
	SessionAffinityAttributes map[string]*string `json:"sessionAffinityAttributes,omitempty" tf:"session_affinity_attributes,omitempty"`

	// Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless [`session_affinity_ttl`](#session_affinity_ttl) is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
	// +kubebuilder:validation:Optional
	SessionAffinityTTL *float64 `json:"sessionAffinityTtl,omitempty" tf:"session_affinity_ttl,omitempty"`

	// The method the load balancer uses to determine the route to your origin. Value `off` uses [`default_pool_ids`](#default_pool_ids). Value `geo` uses [`pop_pools`](#pop_pools)/[`country_pools`](#country_pools)/[`region_pools`](#region_pools). For non-proxied requests, the [`country`](#country) for [`country_pools`](#country_pools) is determined by [`location_strategy`](#location_strategy). Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in [`default_pool_ids`](#default_pool_ids) (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by [`location_strategy`](#location_strategy) for non-proxied requests. Value `""` maps to `geo` if you use [`pop_pools`](#pop_pools)/[`country_pools`](#country_pools)/[`region_pools`](#region_pools) otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `""` Defaults to `""`.
	// +kubebuilder:validation:Optional
	SteeringPolicy *string `json:"steeringPolicy,omitempty" tf:"steering_policy,omitempty"`

	// Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`

	// The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**
	// +crossplane:generate:reference:type=github.com/cdloh/provider-cloudflare/apis/zone/v1alpha1.Zone
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// Reference to a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// Selector for a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

type LocationStrategyObservation struct {
}

type LocationStrategyParameters struct {

	// Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when [`steering_policy="proximity"`](#steering_policy), and `geo` will prefer ECS only when [`steering_policy="geo"`](#steering_policy). Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
	// +kubebuilder:validation:Optional
	PreferEcs *string `json:"preferEcs,omitempty" tf:"prefer_ecs,omitempty"`
}

type OverridesAdaptiveRoutingObservation struct {
}

type OverridesAdaptiveRoutingParameters struct {

	// See [`failover_across_pools`](#failover_across_pools).
	// +kubebuilder:validation:Optional
	FailoverAcrossPools *bool `json:"failoverAcrossPools,omitempty" tf:"failover_across_pools,omitempty"`
}

type OverridesCountryPoolsObservation struct {
}

type OverridesCountryPoolsParameters struct {

	// See [`country`](#country).
	// +kubebuilder:validation:Required
	Country *string `json:"country" tf:"country,omitempty"`

	// See [`pool_ids`](#pool_ids).
	// +kubebuilder:validation:Required
	PoolIds []*string `json:"poolIds" tf:"pool_ids,omitempty"`
}

type OverridesLocationStrategyObservation struct {
}

type OverridesLocationStrategyParameters struct {

	// See [`mode`](#mode).
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// See [`prefer_ecs`](#prefer_ecs).
	// +kubebuilder:validation:Optional
	PreferEcs *string `json:"preferEcs,omitempty" tf:"prefer_ecs,omitempty"`
}

type OverridesObservation struct {
}

type OverridesParameters struct {

	// See [`adaptive_routing`](#adaptive_routing).
	// +kubebuilder:validation:Optional
	AdaptiveRouting []OverridesAdaptiveRoutingParameters `json:"adaptiveRouting,omitempty" tf:"adaptive_routing,omitempty"`

	// See [`country_pools`](#country_pools).
	// +kubebuilder:validation:Optional
	CountryPools []OverridesCountryPoolsParameters `json:"countryPools,omitempty" tf:"country_pools,omitempty"`

	// See [`default_pool_ids`](#default_pool_ids).
	// +kubebuilder:validation:Optional
	DefaultPools []*string `json:"defaultPools,omitempty" tf:"default_pools,omitempty"`

	// See [`fallback_pool_id`](#fallback_pool_id).
	// +kubebuilder:validation:Optional
	FallbackPool *string `json:"fallbackPool,omitempty" tf:"fallback_pool,omitempty"`

	// See [`location_strategy`](#location_strategy).
	// +kubebuilder:validation:Optional
	LocationStrategy []OverridesLocationStrategyParameters `json:"locationStrategy,omitempty" tf:"location_strategy,omitempty"`

	// See [`pop_pools`](#pop_pools).
	// +kubebuilder:validation:Optional
	PopPools []OverridesPopPoolsParameters `json:"popPools,omitempty" tf:"pop_pools,omitempty"`

	// See [`random_steering`](#random_steering).
	// +kubebuilder:validation:Optional
	RandomSteering []OverridesRandomSteeringParameters `json:"randomSteering,omitempty" tf:"random_steering,omitempty"`

	// See [`region_pools`](#region_pools).
	// +kubebuilder:validation:Optional
	RegionPools []OverridesRegionPoolsParameters `json:"regionPools,omitempty" tf:"region_pools,omitempty"`

	// See [`session_affinity`](#session_affinity).
	// +kubebuilder:validation:Optional
	SessionAffinity *string `json:"sessionAffinity,omitempty" tf:"session_affinity,omitempty"`

	// See [`session_affinity_attributes`](#nested-schema-for-session_affinity_attributes). Note that the property [`drain_duration`](#drain_duration) is not currently supported as a rule override.
	// +kubebuilder:validation:Optional
	SessionAffinityAttributes map[string]*string `json:"sessionAffinityAttributes,omitempty" tf:"session_affinity_attributes,omitempty"`

	// See [`session_affinity_ttl`](#session_affinity_ttl).
	// +kubebuilder:validation:Optional
	SessionAffinityTTL *float64 `json:"sessionAffinityTtl,omitempty" tf:"session_affinity_ttl,omitempty"`

	// See [`steering_policy`](#steering_policy).
	// +kubebuilder:validation:Optional
	SteeringPolicy *string `json:"steeringPolicy,omitempty" tf:"steering_policy,omitempty"`

	// See [`ttl`](#ttl).
	// +kubebuilder:validation:Optional
	TTL *float64 `json:"ttl,omitempty" tf:"ttl,omitempty"`
}

type OverridesPopPoolsObservation struct {
}

type OverridesPopPoolsParameters struct {

	// See [`pool_ids`](#pool_ids).
	// +kubebuilder:validation:Required
	PoolIds []*string `json:"poolIds" tf:"pool_ids,omitempty"`

	// See [`pop`](#pop).
	// +kubebuilder:validation:Required
	Pop *string `json:"pop" tf:"pop,omitempty"`
}

type OverridesRandomSteeringObservation struct {
}

type OverridesRandomSteeringParameters struct {

	// See [`default_weight`](#default_weight).
	// +kubebuilder:validation:Optional
	DefaultWeight *float64 `json:"defaultWeight,omitempty" tf:"default_weight,omitempty"`

	// See [`pool_weights`](#pool_weights).
	// +kubebuilder:validation:Optional
	PoolWeights map[string]*float64 `json:"poolWeights,omitempty" tf:"pool_weights,omitempty"`
}

type OverridesRegionPoolsObservation struct {
}

type OverridesRegionPoolsParameters struct {

	// See [`pool_ids`](#pool_ids).
	// +kubebuilder:validation:Required
	PoolIds []*string `json:"poolIds" tf:"pool_ids,omitempty"`

	// See [`region`](#region).
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`
}

type PopPoolsObservation struct {
}

type PopPoolsParameters struct {

	// A list of pool IDs in failover priority to use for traffic reaching the given PoP.
	// +crossplane:generate:reference:type=Pool
	// +kubebuilder:validation:Optional
	PoolIds []*string `json:"poolIds,omitempty" tf:"pool_ids,omitempty"`

	// References to Pool to populate poolIds.
	// +kubebuilder:validation:Optional
	PoolIdsRefs []v1.Reference `json:"poolIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Pool to populate poolIds.
	// +kubebuilder:validation:Optional
	PoolIdsSelector *v1.Selector `json:"poolIdsSelector,omitempty" tf:"-"`

	// A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
	// +kubebuilder:validation:Required
	Pop *string `json:"pop" tf:"pop,omitempty"`
}

type RandomSteeringObservation struct {
}

type RandomSteeringParameters struct {

	// The default weight for pools in the load balancer that are not specified in the [`pool_weights`](#pool_weights) map.
	// +kubebuilder:validation:Optional
	DefaultWeight *float64 `json:"defaultWeight,omitempty" tf:"default_weight,omitempty"`

	// A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
	// +kubebuilder:validation:Optional
	PoolWeights map[string]*float64 `json:"poolWeights,omitempty" tf:"pool_weights,omitempty"`
}

type RegionPoolsObservation struct {
}

type RegionPoolsParameters struct {

	// A list of pool IDs in failover priority to use in the given region.
	// +crossplane:generate:reference:type=Pool
	// +kubebuilder:validation:Optional
	PoolIds []*string `json:"poolIds,omitempty" tf:"pool_ids,omitempty"`

	// References to Pool to populate poolIds.
	// +kubebuilder:validation:Optional
	PoolIdsRefs []v1.Reference `json:"poolIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Pool to populate poolIds.
	// +kubebuilder:validation:Optional
	PoolIdsSelector *v1.Selector `json:"poolIdsSelector,omitempty" tf:"-"`

	// A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`
}

type RulesObservation struct {
}

type RulesParameters struct {

	// The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
	// +kubebuilder:validation:Optional
	Condition *string `json:"condition,omitempty" tf:"condition,omitempty"`

	// A disabled rule will not be executed.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: [`overrides`](#overrides) or [`fixed_response`](#fixed_response) must be set.
	// +kubebuilder:validation:Optional
	FixedResponse []FixedResponseParameters `json:"fixedResponse,omitempty" tf:"fixed_response,omitempty"`

	// Human readable name for this rule.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The load balancer settings to alter if this rule's [`condition`](#condition) is true. Note: [`overrides`](#overrides) or [`fixed_response`](#fixed_response) must be set.
	// +kubebuilder:validation:Optional
	Overrides []OverridesParameters `json:"overrides,omitempty" tf:"overrides,omitempty"`

	// Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// Terminates indicates that if this rule is true no further rules should be executed. Note: setting a [`fixed_response`](#fixed_response) forces this field to `true`.
	// +kubebuilder:validation:Optional
	Terminates *bool `json:"terminates,omitempty" tf:"terminates,omitempty"`
}

// LoadBalancerSpec defines the desired state of LoadBalancer
type LoadBalancerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LoadBalancerParameters `json:"forProvider"`
}

// LoadBalancerStatus defines the observed state of LoadBalancer.
type LoadBalancerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LoadBalancerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancer is the Schema for the LoadBalancers API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type LoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadBalancerSpec   `json:"spec"`
	Status            LoadBalancerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LoadBalancerList contains a list of LoadBalancers
type LoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoadBalancer `json:"items"`
}

// Repository type metadata.
var (
	LoadBalancer_Kind             = "LoadBalancer"
	LoadBalancer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LoadBalancer_Kind}.String()
	LoadBalancer_KindAPIVersion   = LoadBalancer_Kind + "." + CRDGroupVersion.String()
	LoadBalancer_GroupVersionKind = CRDGroupVersion.WithKind(LoadBalancer_Kind)
)

func init() {
	SchemeBuilder.Register(&LoadBalancer{}, &LoadBalancerList{})
}
