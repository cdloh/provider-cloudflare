/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type HostnameInitParameters struct {

	// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// The custom origin server used for certificates.
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// SSL properties used when creating the custom hostname.
	SSL []SSLInitParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
	WaitForSSLPendingValidation *bool `json:"waitForSslPendingValidation,omitempty" tf:"wait_for_ssl_pending_validation,omitempty"`
}

type HostnameObservation struct {

	// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// The custom origin server used for certificates.
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	OwnershipVerification map[string]*string `json:"ownershipVerification,omitempty" tf:"ownership_verification,omitempty"`

	OwnershipVerificationHTTP map[string]*string `json:"ownershipVerificationHttp,omitempty" tf:"ownership_verification_http,omitempty"`

	// SSL properties used when creating the custom hostname.
	SSL []SSLObservation `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// Status of the certificate.
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
	WaitForSSLPendingValidation *bool `json:"waitForSslPendingValidation,omitempty" tf:"wait_for_ssl_pending_validation,omitempty"`

	// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type HostnameParameters struct {

	// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
	// +kubebuilder:validation:Optional
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// The custom origin server used for certificates.
	// +kubebuilder:validation:Optional
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
	// +kubebuilder:validation:Optional
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// SSL properties used when creating the custom hostname.
	// +kubebuilder:validation:Optional
	SSL []SSLParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
	// +kubebuilder:validation:Optional
	WaitForSSLPendingValidation *bool `json:"waitForSslPendingValidation,omitempty" tf:"wait_for_ssl_pending_validation,omitempty"`

	// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
	// +crossplane:generate:reference:type=github.com/clementblaise/provider-cloudflare/apis/zone/v1alpha1.Zone
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// Reference to a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// Selector for a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

type SSLInitParameters struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	CustomKey *string `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// SSL/TLS settings for the certificate.
	Settings []SettingsInitParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Indicates whether the certificate covers a wildcard.
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SSLObservation struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	CustomKey *string `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// SSL/TLS settings for the certificate.
	Settings []SettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	ValidationErrors []ValidationErrorsObservation `json:"validationErrors,omitempty" tf:"validation_errors,omitempty"`

	ValidationRecords []ValidationRecordsObservation `json:"validationRecords,omitempty" tf:"validation_records,omitempty"`

	// Indicates whether the certificate covers a wildcard.
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SSLParameters struct {

	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// If a custom uploaded certificate is used.
	// +kubebuilder:validation:Optional
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// The key for a custom uploaded certificate.
	// +kubebuilder:validation:Optional
	CustomKey *string `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// SSL/TLS settings for the certificate.
	// +kubebuilder:validation:Optional
	Settings []SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Indicates whether the certificate covers a wildcard.
	// +kubebuilder:validation:Optional
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SettingsInitParameters struct {

	// List of SSL/TLS ciphers to associate with this certificate.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Whether early hints should be supported. Available values: `on`, `off`.
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// Whether HTTP2 should be supported. Available values: `on`, `off`.
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// Whether TLSv1.3 should be supported. Available values: `on`, `off`.
	Tls13 *string `json:"tls13,omitempty" tf:"tls13,omitempty"`
}

type SettingsObservation struct {

	// List of SSL/TLS ciphers to associate with this certificate.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Whether early hints should be supported. Available values: `on`, `off`.
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// Whether HTTP2 should be supported. Available values: `on`, `off`.
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// Whether TLSv1.3 should be supported. Available values: `on`, `off`.
	Tls13 *string `json:"tls13,omitempty" tf:"tls13,omitempty"`
}

type SettingsParameters struct {

	// List of SSL/TLS ciphers to associate with this certificate.
	// +kubebuilder:validation:Optional
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// Whether early hints should be supported. Available values: `on`, `off`.
	// +kubebuilder:validation:Optional
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// Whether HTTP2 should be supported. Available values: `on`, `off`.
	// +kubebuilder:validation:Optional
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
	// +kubebuilder:validation:Optional
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// Whether TLSv1.3 should be supported. Available values: `on`, `off`.
	// +kubebuilder:validation:Optional
	Tls13 *string `json:"tls13,omitempty" tf:"tls13,omitempty"`
}

type ValidationErrorsInitParameters struct {
}

type ValidationErrorsObservation struct {
	Message *string `json:"message,omitempty" tf:"message,omitempty"`
}

type ValidationErrorsParameters struct {
}

type ValidationRecordsInitParameters struct {
}

type ValidationRecordsObservation struct {
	CnameName *string `json:"cnameName,omitempty" tf:"cname_name,omitempty"`

	CnameTarget *string `json:"cnameTarget,omitempty" tf:"cname_target,omitempty"`

	Emails []*string `json:"emails,omitempty" tf:"emails,omitempty"`

	HTTPBody *string `json:"httpBody,omitempty" tf:"http_body,omitempty"`

	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url,omitempty"`

	TxtName *string `json:"txtName,omitempty" tf:"txt_name,omitempty"`

	TxtValue *string `json:"txtValue,omitempty" tf:"txt_value,omitempty"`
}

type ValidationRecordsParameters struct {
}

// HostnameSpec defines the desired state of Hostname
type HostnameSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     HostnameParameters `json:"forProvider"`
	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider HostnameInitParameters `json:"initProvider,omitempty"`
}

// HostnameStatus defines the observed state of Hostname.
type HostnameStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        HostnameObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Hostname is the Schema for the Hostnames API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type Hostname struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.hostname) || has(self.initProvider.hostname)",message="hostname is a required parameter"
	Spec   HostnameSpec   `json:"spec"`
	Status HostnameStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// HostnameList contains a list of Hostnames
type HostnameList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Hostname `json:"items"`
}

// Repository type metadata.
var (
	Hostname_Kind             = "Hostname"
	Hostname_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Hostname_Kind}.String()
	Hostname_KindAPIVersion   = Hostname_Kind + "." + CRDGroupVersion.String()
	Hostname_GroupVersionKind = CRDGroupVersion.WithKind(Hostname_Kind)
)

func init() {
	SchemeBuilder.Register(&Hostname{}, &HostnameList{})
}
