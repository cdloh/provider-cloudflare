/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CustomSSLOptionsInitParameters struct {

	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are ubiquitous (default), optimal, force.
	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// Certificate certificate and the intermediate(s)
	// Certificate certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Specifies the region where your private key can be held locally. Valid values are us, eu, highest_security.
	// Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
	GeoRestrictions *string `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are legacy_custom (default), sni_custom.
	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomSSLOptionsObservation struct {

	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are ubiquitous (default), optimal, force.
	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// Certificate certificate and the intermediate(s)
	// Certificate certificate and the intermediate(s).
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Specifies the region where your private key can be held locally. Valid values are us, eu, highest_security.
	// Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
	GeoRestrictions *string `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are legacy_custom (default), sni_custom.
	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomSSLOptionsParameters struct {

	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Valid values are ubiquitous (default), optimal, force.
	// Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// Certificate certificate and the intermediate(s)
	// Certificate certificate and the intermediate(s).
	// +kubebuilder:validation:Optional
	Certificate *string `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// Specifies the region where your private key can be held locally. Valid values are us, eu, highest_security.
	// Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
	// +kubebuilder:validation:Optional
	GeoRestrictions *string `json:"geoRestrictions,omitempty" tf:"geo_restrictions,omitempty"`

	// Certificate's private key
	// Certificate's private key.
	// +kubebuilder:validation:Optional
	PrivateKeySecretRef *v1.SecretKeySelector `json:"privateKeySecretRef,omitempty" tf:"-"`

	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Valid values are legacy_custom (default), sni_custom.
	// Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type CustomSSLPriorityInitParameters struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type CustomSSLPriorityObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type CustomSSLPriorityParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`
}

type SSLInitParameters struct {

	// The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.
	// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
	CustomSSLOptions []CustomSSLOptionsInitParameters `json:"customSslOptions,omitempty" tf:"custom_ssl_options,omitempty"`

	CustomSSLPriority []CustomSSLPriorityInitParameters `json:"customSslPriority,omitempty" tf:"custom_ssl_priority,omitempty"`
}

type SSLObservation struct {

	// The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.
	// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
	CustomSSLOptions []CustomSSLOptionsObservation `json:"customSslOptions,omitempty" tf:"custom_ssl_options,omitempty"`

	CustomSSLPriority []CustomSSLPriorityObservation `json:"customSslPriority,omitempty" tf:"custom_ssl_priority,omitempty"`

	ExpiresOn *string `json:"expiresOn,omitempty" tf:"expires_on,omitempty"`

	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Issuer *string `json:"issuer,omitempty" tf:"issuer,omitempty"`

	ModifiedOn *string `json:"modifiedOn,omitempty" tf:"modified_on,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	Signature *string `json:"signature,omitempty" tf:"signature,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	UploadedOn *string `json:"uploadedOn,omitempty" tf:"uploaded_on,omitempty"`

	// The DNS zone id to the custom ssl cert should be added.
	// The zone identifier to target for the resource.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type SSLParameters struct {

	// The certificate, private key and associated optional parameters, such as bundle_method, geo_restrictions, and type.
	// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
	// +kubebuilder:validation:Optional
	CustomSSLOptions []CustomSSLOptionsParameters `json:"customSslOptions,omitempty" tf:"custom_ssl_options,omitempty"`

	// +kubebuilder:validation:Optional
	CustomSSLPriority []CustomSSLPriorityParameters `json:"customSslPriority,omitempty" tf:"custom_ssl_priority,omitempty"`

	// The DNS zone id to the custom ssl cert should be added.
	// The zone identifier to target for the resource.
	// +crossplane:generate:reference:type=github.com/clementblaise/provider-cloudflare/apis/zone/v1alpha1.Zone
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// Reference to a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// Selector for a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

// SSLSpec defines the desired state of SSL
type SSLSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SSLParameters `json:"forProvider"`
	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SSLInitParameters `json:"initProvider,omitempty"`
}

// SSLStatus defines the observed state of SSL.
type SSLStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SSLObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SSL is the Schema for the SSLs API. Provides a Cloudflare custom SSL resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type SSL struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SSLSpec   `json:"spec"`
	Status            SSLStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SSLList contains a list of SSLs
type SSLList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SSL `json:"items"`
}

// Repository type metadata.
var (
	SSL_Kind             = "SSL"
	SSL_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SSL_Kind}.String()
	SSL_KindAPIVersion   = SSL_Kind + "." + CRDGroupVersion.String()
	SSL_GroupVersionKind = CRDGroupVersion.WithKind(SSL_Kind)
)

func init() {
	SchemeBuilder.Register(&SSL{}, &SSLList{})
}
